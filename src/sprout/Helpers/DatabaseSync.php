<?php
/*
 * Copyright (C) 2017 Karmabunny Pty Ltd.
 *
 * This file is a part of SproutCMS.
 *
 * SproutCMS is free software: you can redistribute it and/or modify it under the terms
 * of the GNU General Public License as published by the Free Software Foundation, either
 * version 2 of the License, or (at your option) any later version.
 *
 * For more information, visit <http://getsproutcms.com>.
 */

// kate: tab-width 4; indent-width 4; space-indent on; word-wrap off; word-wrap-column 120;
// :tabSize=4:indentSize=4:noTabs=true:wrap=false:maxLineLen=120:mode=php:

namespace Sprout\Helpers;

use DOMDocument;
use Exception;

use Kohana;

use Sprout\Exceptions\QueryException;


/**
* Provides a system for syncing a database to a database definition.
*
* The database definition is stored in one or more XML files, which get merged
* together before the sync is done.
* Contains code that may be MySQL specific.
**/
class DatabaseSync
{
    public $tables;
    private $views;
    private $default_attrs;
    private $db;
    private $load_errors;
    private $act;
    private $extant_tables = null;

    /** Temporarily stores heading to attach to next query generated */
    private $heading = "<p><b>TBA</b>\n";

    /** Set of queries to run. Stored out of order, then ordered and run once all queries have been generated */
    private $queries = [];

    /* Types of queries generated by running a sync, in the order that they should be run */
    private static $query_types = [
        'alter_table',
        'alter_column',
        'rename_table',
        'rename_col',
        'drop_fk',
        'drop_index',
        'drop_column',
        'add_table',
        'insert_record',
        'add_column',
        'add_index',
        'alter_pk',
        'add_fk',
    ];


    /**
    * MySQL names for the foreign key actions
    **/
    private static $foreign_key_actions = array(
        'restrict' => 'RESTRICT',
        'set-null' => 'SET NULL',
        'cascade' => 'CASCADE',
    );


    /**
    * Initial loading and set-up
    *
    * @param bool $act True if queries should be run, false if they shouldn't (i.e. a dry-run)
    **/
    public function __construct($act)
    {
        $this->act = $act;

        $this->default_attrs = array (
            'table' => array('engine' => 'InnoDB', 'charset' => 'utf8', 'collate' => 'utf8_unicode_ci'),
            'column' => array('allownull' => 1),
            'index' => array('type' => 'index')
        );

        $this->tables = array();
        $this->views = array();
        $this->load_errors = array();
    }


    /**
    * Are the permissions of the current user adequate?
    *
    * Return TRUE on success, or an array of missing permissions on failure.
    **/
    public function checkConnPermissions()
    {
        $q = "SHOW GRANTS FOR CURRENT_USER()";
        $res = Pdb::query($q, [], 'col');

        $perms = array();
        $matches = null;
        foreach ($res as $val) {
            preg_match('!GRANT (.+) ON!', $val, $matches);
            $p = explode(', ', strtoupper($matches[1]));
            $perms = array_merge($perms, $p);
        }

        if (in_array('ALL PRIVILEGES', $perms)) {
            return true;
        }

        $require = array('SELECT', 'INSERT', 'UPDATE', 'DELETE', 'CREATE', 'ALTER', 'DROP');
        $missing = array_diff($require, $perms);
        if (count($missing) == 0) return true;

        return $missing;
    }


    /**
    * Adds the default attrs to a node
    *
    * @param DOMElement $node The dom node to operate on
    **/
    private function mergeDefaultAttrs($node)
    {
        $default = @$this->default_attrs[$node->tagName];
        if (! is_array($default)) return;

        foreach ($default as $name => $value) {
            if (! $node->hasAttribute($name)) {
                $node->setAttribute($name, $value);
            }
        }
    }

    /**
    * Generates the SQL that should be used for a column spec
    *
    * The spec goes in the following location in the query:
    *    ALTER TABLE pizzas ADD COLUMN toppings <spec>
    *
    * @param array $column The column spec which the SQL spec should be based on
    * @tag maybe-error-not-mysql
    **/
    private function createSqlColumnSpec($column)
    {
        $spec = $column['type'];

        if ($column['allownull'] == 0) $spec .= ' NOT NULL';
        if ($column['autoinc']) $spec .= ' AUTO_INCREMENT';
        if ($column['default']) $spec .= ' DEFAULT ' . Pdb::getConnection()->quote($column['default']);

        return $spec;
    }

    /**
    * Converts a column type definition to its uppercase variant, leaving the
    * data for ENUM and SET fields alone
    */
    private function typeToUpper($type)
    {
        // Don't force ENUM or SET values to be uppercase
        if (preg_match('/^enum\s*\(/i', $type)) {
            $type = 'ENUM' . substr($type, 4);
            return str_replace("', '", "','", $type);
        } else if (preg_match('/^set\s*\(/i', $type)) {
            $type = 'SET' . substr($type, 3);
            return str_replace("', '", "','", $type);
        } else {
            return strtoupper($type);
        }
    }


    /**
     * Load the db_struct.xml from core and from all modules
     */
    public function loadStandardXmlFiles()
    {
        $this->loadXml(APPPATH . 'db_struct.xml');

        $module_paths = Register::getModuleDirs();
        foreach ($module_paths as $path) {
            $path .= '/db_struct.xml';
            if (file_exists($path)) {
                $this->loadXml($path);
            }
        }
    }


    /**
    * Loads the XML definition file
    *
    * @param string $file DOMDocument or filename to load.
    **/
    public function loadXml($dom)
    {
        // If its not a DOMDocument, assume a filename
        if ($dom instanceof DOMDocument) {
            $filename = $dom->documentURI;
        } else {
            $filename = $dom;
            $tmp = new DOMDocument();
            $tmp->loadXML(file_get_contents($filename));
            if ($tmp == null) {
                $this->load_errors[$filename] = array('XML parse error');
                return;
            }
            $dom = $tmp;
        }

        // Validate the XML file against the XSD schema
        libxml_use_internal_errors(true);
        $result = $dom->schemaValidateSource(file_get_contents(DOCROOT . 'sprout/config/db_struct.xsd'));
        if (! $result) {
            $this->load_errors[$filename] = array();

            $errors = libxml_get_errors();
            foreach ($errors as $error) {
                switch ($error->level) {
                    case LIBXML_ERR_WARNING:
                        $err = "<b>Warning {$error->code}</b>: ";
                        break;
                    case LIBXML_ERR_ERROR:
                        $err = "<b>Error {$error->code}</b>: ";
                        break;
                    case LIBXML_ERR_FATAL:
                        $err = "<b>Fatal Error {$error->code}</b>: ";
                        break;
                }
                $err .= Enc::html(trim($error->message));
                $err .= " on line <b>{$error->line}</b>";
                $this->load_errors[$filename][] = $err;
            }

            libxml_clear_errors();
        }
        libxml_use_internal_errors(false);

        // Tables
        $table_nodes = $dom->getElementsByTagName('table');
        foreach ($table_nodes as $table_node) {
            if ($table_node->parentNode->tagName == 'defaults') continue;

            $this->mergeDefaultAttrs($table_node);

            if (! $table_node->hasAttribute('name')) throw new Exception ('A table exists in the xml without a defined name');
            $table_name = $table_node->getAttribute('name');

            // If the table doesn't exist yet in memory, create it
            // It may already exist if doing a cross-module db structure merge
            $is_new = false;
            if (empty($this->tables[$table_name])) {
                $this->tables[$table_name] = array();
                $this->tables[$table_name]['columns'] = array();
                $this->tables[$table_name]['primary_key'] = array();
                $this->tables[$table_name]['indexes'] = array();
                $this->tables[$table_name]['foreign_keys'] = array();
                $this->tables[$table_name]['default_records'] = array();
                $is_new = true;
            }

            // Columns
            $column_nodes = $table_node->getElementsByTagName('column');
            if ($column_nodes->length > 0) {
                foreach ($column_nodes as $node) {
                    $this->mergeDefaultAttrs($node);

                    $col_name = $node->getAttribute('name');

                    $type = $this->typeToUpper($node->getAttribute('type'));
                    $this->tables[$table_name]['columns'][$col_name] = array(
                        'name' => $col_name,
                        'type' => $type,
                        'allownull' => (int) $node->getAttribute('allownull'),
                        'autoinc' => (int) $node->getAttribute('autoinc'),
                        'default' => $node->getAttribute('default'),
                        'previous-names' => $node->getAttribute('previous-names'),
                    );
                }
            }

            // Indexes
            $index_nodes = $table_node->getElementsByTagName('index');
            foreach ($index_nodes as $node) {
                $this->mergeDefaultAttrs($node);

                $index = array();

                $col_nodes = $node->getElementsByTagName('col');
                foreach ($col_nodes as $col) {
                    $this->mergeDefaultAttrs($col);
                    $col_name = $col->getAttribute('name');
                    $index[] = $col_name;
                }

                $index['type'] = $node->getAttribute('type');

                $this->tables[$table_name]['indexes'][] = $index;

                $fk_nodes = $node->getElementsByTagName('foreign-key');
                if ($fk_nodes->length == 1) {
                    $fk = array();
                    $fk['from_column'] = $index[0];
                    $fk['to_table'] = $fk_nodes->item(0)->getAttribute('table');
                    $fk['to_column'] = $fk_nodes->item(0)->getAttribute('column');
                    $fk['update'] = $fk_nodes->item(0)->getAttribute('update');
                    $fk['delete'] = $fk_nodes->item(0)->getAttribute('delete');
                    $this->tables[$table_name]['foreign_keys'][] = $fk;
                }
            }

            // Only columns and indexes can be merged across XML files.
            if (! $is_new) continue;

            // Attributes (engine, charset, etc)
            foreach ($table_node->attributes as $attr) {
                $this->tables[$table_name]['attrs'][$attr->name] = $attr->value;
            }

            // Primary key
            $primary_nodes = $table_node->getElementsByTagName('primary');
            if ($primary_nodes->length > 0) {
                $primary_nodes = $primary_nodes->item(0)->getElementsByTagName('col');
            }

            if ($primary_nodes) {
                foreach ($primary_nodes as $node) {
                    $this->mergeDefaultAttrs($node);

                    $col_name = $node->getAttribute('name');
                    $this->tables[$table_name]['primary_key'][] = $col_name;
                }
            }

            // Default records
            $default_nodes = $table_node->getElementsByTagName('default_records');
            foreach ($default_nodes as $node) {
                $this->mergeDefaultAttrs($node);

                $record_nodes = $node->getElementsByTagName('record');
                foreach ($record_nodes as $record) {
                    $record_attrs = [];
                    foreach ($record->attributes as $attr) {
                        $record_attrs[$attr->name] = $attr->value;
                    }
                    $this->tables[$table_name]['default_records'][] = $record_attrs;
                }
            }
        }

        // Views
        $views_nodes = $dom->getElementsByTagName('view');
        foreach ($views_nodes as $view_node) {
            if (! $table_node->hasAttribute('name')) throw new Exception ('A view exists in the xml without a defined name');
            $view_name = $view_node->getAttribute('name');

            $this->views[$view_name] = (string) $view_node->firstChild->data;
        }
    }


    /**
    * Run a sanity check over all loaded tables
    **/
    public function sanityCheck()
    {
        foreach ($this->tables as $table_name => $table_def) {
            $errs = $this->tableSanityCheck($table_name, $table_def);
            if (count($errs)) {
                $this->load_errors['table "' . $table_name . '"'] = $errs;
            }
        }
    }


    /**
    * Were there any load or sanity check errors?
    **/
    public function hasLoadErrors()
    {
        return (count($this->load_errors) > 0);
    }


    /**
    * Return HTML of the load or sanity check errors
    *
    * @return string HTML
    **/
    public function getLoadErrorsHtml()
    {
        $out = '';

        foreach ($this->load_errors as $file => $errors) {
            $file = preg_replace('/^' . preg_quote(DOCROOT, '/') . '/', '', $file);

            $out .= "<h3>Errors in " . Enc::html($file) . "</h3>";
            $out .= "<ul>";
            foreach ($errors as $error) {
                $out .= "<li>{$error}</li>";
            }
            $out .= "</ul>";
        }

        return $out;
    }


    /**
    * Executes a set of ALTER TABLE statements which will sync the database to the provided layout
    *
    * @param array $do Which functions to perform. If null, defaults to all functions.
    *    Should be an array of key => val, key = function name, val = 1 to do action, 0 to skip.
    *    Functions:
    *       create    create table, update table attributes
    *       primary   update primary key
    *       column    create/modify columns
    *       index     update indexes
    *       remove    remove columns
    *    If any keys in the specified array do not exist, they will default to skip.
    * @return string HTML processing log
    **/
    public function updateDatabase($do = null)
    {
        if ($do == null) {
            $do = array('create' => 1, 'primary' => 1, 'column' => 1, 'index' => 1, 'foreign_key' => 1, 'remove' => 1);
        }

        $out = '';

        ob_start();
        foreach ($this->tables as $table_name => $table_def) {
            // Check the table exists
            $new_table = false;
            if ($do['create']) {
                if (! $this->checkTableMatches($table_name, $table_def)) {
                    $new_table = true;
                }
            }

            // Check the primary key patches
            if (!$new_table and $do['primary']) {
                if (! $this->checkPrimaryMatches($table_name, $table_def['primary_key'])) {
                    $this->changePrimary($table_name, $table_def['primary_key']);
                }
            }

            // Check each column
            if (!$new_table and $do['column']) {
                $prev_column = '';
                foreach ($table_def['columns'] as $column) {
                    $this->checkColumnMatches($table_name, $column, $prev_column);
                    $prev_column = $column['name'];
                }
            }

            // Check each index
            if (!$new_table and $do['index']) {
                foreach ($table_def['indexes'] as $index) {
                    $this->checkIndexMatches($table_name, $index);
                }
            }

            // Check each foreign key
            if ($do['foreign_key']) {
                foreach ($table_def['foreign_keys'] as $index) {
                    $this->checkForeignKeyMatches($table_name, $index);
                }
            }

            // Remove old columns
            if (!$new_table and $do['remove']) {
                $this->checkRemovedColumns($table_name, $table_def['columns']);
                $this->checkRemovedIndexes($table_name, $table_def['indexes']);
                $this->checkRemovedForeignKeys($table_name, $table_def['foreign_keys']);
            }
        }

        foreach (self::$query_types as $type) {
            if (empty($this->queries[$type])) continue;
            foreach ($this->queries[$type] as $query_data) {
                list($query, $heading, $message) = $query_data;
                echo $heading;
                $this->reportAndExecute($query);
                echo $message;
            }
        }

        $html = ob_get_clean();
        if ($html) {
            $out .= "<h3>Tables</h3>\n";
            $out .= $html;
        }

        ob_start();
        foreach ($this->views as $view_name => $view_def) {
            $this->createView($view_name, $view_def);
        }
        $html = ob_get_clean();
        if ($html) {
            $out .= "<h3>Views</h3>\n";
            $out .= $html;
        }

        return $out;
    }


    /**
    * Do a sanity check on the table definition
    *
    * @param string $table_name The name of the table to check
    * @param array $table_def The table definition
    *
    * @return array Any errors which were detected
    **/
    private function tableSanityCheck($table_name, $table_def)
    {
        $errors = array();

        if (count($table_def['columns']) == 0) {
            $errors[] = 'No columns defined';
            return $errors;
        }

        // Check the id column is an int
        if (!empty($table_def['columns']['id'])) {
            $def = $table_def['columns']['id'];
            if (!preg_match('!^(BIG)?INT UNSIGNED$!i', $def['type'])) {
                $errors[] = 'Bad type for "id" column, use INT UNSIGNED or BIGINT UNSIGNED';
            }
            if ($def['autoinc'] == 1) {
                if (count($table_def['primary_key']) != 1 or $table_def['primary_key'][0] != 'id') {
                    $errors[] = 'Column is autoinc, but isn\'t only column in primary key';
                }
            }
        }

        // Check primary key exists and has columns
        if (empty($table_def['primary_key'])) {
            $errors[] = 'No primary key defined';
        } else {
            if (count($table_def['primary_key']) == 0) {
                $errors[] = 'Primary key doesn\'t have any columns';
            }
        }

        // Check types match on both sites of the reference
        // Check column is nullable if SET NULL is used
        // Check the TO side of the reference is indexed
        foreach ($table_def['foreign_keys'] as $fk) {
            $from_column = @$table_def['columns'][$fk['from_column']];
            $to_column = @$this->tables[$fk['to_table']]['columns'][$fk['to_column']];

            if (!$from_column) {
                $errors[] = "Foreign key \"{$fk['from_column']}\" on unknown column \"{$table_name}.{$fk['from_column']}\"";
                continue;
            }

            if (!$to_column) {
                $errors[] = "Foreign key \"{$fk['from_column']}\" points to unknown column \"{$fk['to_table']}.{$fk['to_column']}\"";
                continue;
            }

            if ($to_column['type'] != $from_column['type']) {
                $errors[] = 'Foreign key "' . $fk['from_column'] . '" column type mismatch (' . $to_column['type'] . ' vs ' . $from_column['type'] . ')';
            }

            if ($fk['update'] == 'set-null' and $table_def['columns'][$fk['from_column']]['allownull'] == 0) {
                $errors[] = 'Foreign key "' . $fk['from_column'] . '" update action to SET NULL but column doesn\'t allow nulls';
            }

            if ($fk['delete'] == 'set-null' and $table_def['columns'][$fk['from_column']]['allownull'] == 0) {
                $errors[] = 'Foreign key "' . $fk['from_column'] . '" delete action to SET NULL but column doesn\'t allow nulls';
            }

            $index_found = false;
            if (@$this->tables[$fk['to_table']]['primary_key'][0] == $fk['to_column']) {
                $index_found = true;
            } else {
                foreach ($this->tables[$fk['to_table']]['indexes'] as $index) {
                    if ($index[0] == $fk['to_column']) {
                        $index_found = true;
                        break;
                    }
                }
            }
            if (! $index_found) {
                $errors[] = 'Foreign key "' . $fk['from_column'] . '" referenced column (' . $fk['to_table'] . '.' . $fk['to_column'] . ') is not first column in an index';
            }
        }


        return $errors;
    }


    /**
     * Fetches the current list of tables, caching them on the first call
     * @return array Each element is a table name
     */
    private function listTables()
    {
        if ($this->extant_tables === null) {
            $this->extant_tables = [];
            $res = Pdb::query('SHOW TABLE STATUS', [], 'pdo');
            foreach ($res as $row) {
                $this->extant_tables[$row['Name']] = $row;
            }
            $res->closeCursor();
        }
        return array_keys($this->extant_tables);
    }

    private function tableExists($table_name)
    {
        return in_array(Pdb::prefix() . $table_name, $this->listTables());
    }

    public function fieldList($table)
    {
        static $known = [];
        if (isset($known[$table])) return $known[$table];

        $q = "SHOW COLUMNS FROM ~{$table}";
        $res = Pdb::query($q, [], 'arr');
        $known[$table] = $res;
        return $res;
    }

    public function indexList($table)
    {
        static $known = [];
        if (isset($known[$table])) return $known[$table];

        $q = "SHOW INDEX FROM ~{$table}";
        $res = Pdb::query($q, [], 'arr');

        $indexes = array();
        foreach ($res as $row) {
            $indexes[$row['Key_name']]['Name'] = $row['Key_name'];
            $indexes[$row['Key_name']]['Type'] = $row['Non_unique'] ? 'INDEX' : 'UNIQUE';
            $indexes[$row['Key_name']]['Columns'][] = $row['Column_name'];
        }
        $known[$table] = $indexes;
        return $indexes;
    }


    /**
     * Gets the current list of foreign keys in a table
     * On first run, this fetches the foreign keys for all tables, and caches the results
     * @param string $table The name of the table (without prefix)
     * @return array Each element is a foreign key constraint row with keys TABLE_NAME, COLUMN_NAME, CONSTRAINT_NAME,
     *         REFERENCED_TABLE_NAME, REFERENCED_COLUMN_NAME, UPDATE_RULE, DELETE_RULE
     */
    public function foreignKeyList($table)
    {
        static $known = null;
        $table = Pdb::prefix() . $table;

        if ($known !== null) {
            if (isset($known[$table])) return $known[$table];
            return [];
        }

        $dbname = Kohana::config('database.default.connection.database');
        $known = [];
        $q = "SELECT K.TABLE_NAME, K.COLUMN_NAME, K.CONSTRAINT_NAME, K.REFERENCED_TABLE_NAME, K.REFERENCED_COLUMN_NAME,
                C.UPDATE_RULE, C.DELETE_RULE
            FROM INFORMATION_SCHEMA.KEY_COLUMN_USAGE AS K
            INNER JOIN INFORMATION_SCHEMA.REFERENTIAL_CONSTRAINTS AS C
                ON K.CONSTRAINT_NAME = C.CONSTRAINT_NAME
                AND K.TABLE_SCHEMA = C.CONSTRAINT_SCHEMA
            WHERE K.TABLE_SCHEMA = '{$dbname}'
                AND K.CONSTRAINT_NAME != ''
                AND K.REFERENCED_TABLE_NAME != ''
                AND K.REFERENCED_COLUMN_NAME != ''
            ORDER BY K.CONSTRAINT_NAME";
        $res = Pdb::q($q, [], 'pdo');
        foreach ($res as $row) {
            $known[$row['TABLE_NAME']][] = $row;
        }
        if (!isset($known[$table])) return [];
        return $known[$table];
    }


    /**
    * Checks that the specified table exists
    * If the table does not exist, it will be created.
    *
    * @param string $table_name The name of the table to check
    * @param array $table_def The table definition
    *
    * @return bool False if the table did not exist and was just then created, true otherwise
    **/
    private function checkTableMatches($table_name, $table_def)
    {
        $table_name = trim($table_name);

        // If the table does not exist, create it
        if (! $this->tableExists($table_name)) {
            $previous_found = false;
            if (isset($table_def['attrs']['previous-names'])) {
                $names = explode(',', $table_def['attrs']['previous-names']);

                // Search previous names for a match; if found the table is renamed
                foreach ($names as $n) {
                    if ($this->tableExists($n)) {
                        $this->heading = "<p class=\"heading\"><b>RENAME</b> Table '{$n}' to '{$table_name}'</p>\n";
                        $q = "RENAME TABLE ~{$n} TO ~{$table_name}";
                        $this->storeQuery('rename_table', $q);
                        $previous_found = true;
                        break;
                    }
                }
            }

            if (!$previous_found) {
                $this->heading = "<p class=\"heading\"><b>MISSING</b> Table '{$table_name}'</p>\n";
                $this->createTable($table_name, $table_def);
            }

            return false;
        }

        $table_name = Pdb::prefix() . $table_name;
        $row = $this->extant_tables[$table_name];

        $bad_engine = false;
        if ($row['Engine'] != $table_def['attrs']['engine']) {
            $bad_engine = true;
        }

        $bad_collate = false;
        if ($row['Collation'] != $table_def['attrs']['collate']) {
            $bad_collate = true;
        }

        if ($bad_engine or $bad_collate) {
            $this->heading = "<p class=\"heading\"><b>ATTRS</b> Table '{$table_name}'</p>\n";

            $q = "ALTER TABLE {$table_name}";
            $q .= " ENGINE = {$table_def['attrs']['engine']},";
            $q .= " CHARACTER SET = '{$table_def['attrs']['charset']}',";
            $q .= " COLLATE = '{$table_def['attrs']['collate']}'";

            $this->storeQuery('alter_table', $q);

            $q = "ALTER TABLE {$table_name}";
            $q .= " CONVERT TO CHARACTER SET {$table_def['attrs']['charset']}";
            $q .= " COLLATE {$table_def['attrs']['collate']}";

            $this->storeQuery('alter_table', $q);
        }

        return true;
    }


    /**
    * Creates a table which matches the specified definition
    *
    * @param string $table_name The name of the table to create
    * @param array $table_def The table definition
    * @tag maybe-error-not-mysql
    **/
    private function createTable($table_name, $table_def)
    {
        Pdb::validateIdentifier($table_name);

        $q = "CREATE TABLE ~{$table_name} (\n";

        foreach ($table_def['columns'] as $column_name => $def) {
            $spec = $this->createSqlColumnSpec($def);
            $q .= "  `{$column_name}` {$spec},\n";
        }

        if (@count($table_def['primary_key'])) {
            $q .= "  PRIMARY KEY (`" . implode('`,`', $table_def['primary_key']) . "`),\n";
        }

        foreach ($table_def['indexes'] as $index) {
            $type = strtoupper($index['type']);
            unset ($index['type']);

            $q .= "  {$type} (`" . implode('`,`', $index) . "`),\n";
        }

        $q = preg_replace("/,\n$/", "\n)", $q);

        $q .= " ENGINE = {$table_def['attrs']['engine']},";
        $q .= " CHARACTER SET = '{$table_def['attrs']['charset']}',";
        $q .= " COLLATE = '{$table_def['attrs']['collate']}'";

        $msg = ($this->act ? "Table created successfully.\n" : '');
        $this->storeQuery('add_table', $q, $msg);


        // Default records
        $pdo = Pdb::getConnection();
        foreach ($table_def['default_records'] as $record) {
            $q = "INSERT INTO ~{$table_name} (";

            $vals = '';
            foreach ($record as $col => $val) {
                if ($vals != '') {
                    $q .= ', ';
                    $vals .= ', ';
                }
                $q .= "`{$col}`";
                $vals .= $pdo->quote($val);
            }
            $q .= ") VALUES ({$vals})";

            $this->storeQuery('insert_record', $q);
        }
        return true;
    }


    /**
    * Checks that the specified primary key is correct for the table
    *
    * @param string $table_name The name of the table to check
    * @param array $primary The primary key definition
    * @tag maybe-error-not-mysql
    **/
    private function checkPrimaryMatches($table_name, $primary)
    {
        $columns = $this->fieldList($table_name);

        $key = array();
        foreach ($columns as $col) {
            if ($col['Key'] == 'PRI') {
                $key[] = $col['Field'];
            }
        }

        if ($key == $primary) return true;

        $this->heading = "<p class=\"heading\"><b>PRIMARY</b> Table '{$table_name}'</p>\n";
        return false;
    }


    /**
    * Changes the primary key of a table
    *
    * @param string $table_name The name of the table to alter
    * @param array $primary The new primary key definition
    * @tag maybe-error-not-mysql
    **/
    private function changePrimary($table_name, $primary)
    {
        $table_name = Pdb::prefix() . $table_name;
        $columns = implode (', ', $primary);

        $q = "ALTER TABLE {$table_name} DROP PRIMARY KEY, ADD PRIMARY KEY ({$columns})";
        $this->storeQuery('alter_pk', $q);

        return true;
    }


    /**
    * Checks that the specified column exists in the specified table
    * If the column is incorrect, it will be altered
    * If the column does not exist, it will be created
    *
    * @param string $table_name The name of the table to check
    * @param array $column The column definition to check
    * @param string $prev_column The name of the previous column, for column positioning
    * @tag maybe-error-not-mysql
    **/
    private function checkColumnMatches($table_name, $column, $prev_column)
    {
        $current_columns = array();
        $res = $this->fieldList($table_name);
        foreach ($res as $row) {
            $current_columns[$row['Field']] = $row;
        }

        // If not found, create it
        if (!isset($current_columns[$column['name']])) {
            $spec = $this->createSqlColumnSpec($column);

            // Search for a rename first, if so do it and then return
            $previous_found = false;
            if (isset($column['previous-names'])) {
                $names = explode(',', $column['previous-names']);

                // Search previous names for a match; if found the table is renamed
                foreach ($names as $n) {
                    if (isset($current_columns[$n])) {
                        $this->heading = "<p class=\"heading\"><b>RENAME</b> Column '{$n}' to '{$column['name']}'</p>\n";
                        $q = "ALTER TABLE ~{$table_name} CHANGE COLUMN {$n} {$column['name']} {$spec}";
                        $this->storeQuery('rename_col', $q);
                        return true;
                    }
                }
            }

            $this->heading = "<p class=\"heading\"><b>MISSING</b> Table '{$table_name}', Column '{$column['name']}'</p>\n";
            $q = "ALTER TABLE ~{$table_name} ADD COLUMN {$column['name']} {$spec}";

            // Use the MySQL-only AFTER syntax where possible
            if ($prev_column) {
                $q = ["{$q} AFTER {$prev_column}", $q];
            }

            $this->storeQuery('add_column', $q);

            return true;
        }

        $col = $current_columns[$column['name']];

        $type = $this->typeToUpper($col['Type']);
        $type = preg_replace('/INT\([0-9]+\)/', 'INT', $type);

        if (preg_match('/INT/', $type)) {
            $col['Default'] = (int) $col['Default'];
            $column['default'] = (int) $column['default'];
        }

        $matches = true;
        $reason = '';
        if ($type != $column['type']) {$matches = false; $reason .= "type, ";}

        if ($col['Null'] == 'YES' and $column['allownull'] == 0) {$matches = false; $reason .= "null, ";}
        if ($col['Null'] == 'NO' and $column['allownull'] == 1) {$matches = false; $reason .= "null, ";}

        if ($col['Default'] != $column['default']) {$matches = false; $reason .= "default, ";}

        if ($col['Extra'] == 'auto_increment' and $column['autoinc'] == 0) {$matches = false; $reason .= "autoinc, ";}
        if ($col['Extra'] != 'auto_increment' and $column['autoinc'] == 1) {$matches = false; $reason .= "autoinc, ";}

        if (! $matches) {
            $reason = substr($reason, 0, -2);
            $this->heading = "<p class=\"heading\"><b>COLUMN</b> Table '{$table_name}', Column '{$column['name']}' - {$reason}</p>\n";

            $spec = $this->createSqlColumnSpec($column);
            $q = "ALTER TABLE ~{$table_name} MODIFY COLUMN {$column['name']} {$spec}";
            $this->storeQuery('alter_column', $q);

            return true;
        }

        return true;
    }

    /**
    * Checks that the specified index exists in the table
    * If the index is incorrect, it will be altered
    * If the index does not exist, it will be created
    *
    * @param string $table_name The name of the table to check
    * @param array $index The index definition to check
    * @tag maybe-error-not-mysql
    **/
    private function checkIndexMatches($table_name, $index)
    {
        $indexes = $this->indexList($table_name);
        $table_name = Pdb::prefix() . $table_name;

        $type = strtoupper($index['type']);
        unset ($index['type']);
        $cols = implode(', ', $index);

        $action = 'create';
        foreach ($indexes as $name => $info) {
            if ($info['Columns'] == $index and $info['Type'] == $type) {
                $action = null;
                break;

            } else if ($info['Columns'] == $index) {
                $action = 'changetype';
                break;
            }
        }

        if (! $action) {
            return true;
        }

        $this->heading = "<p class=\"heading\"><b>INDEX</b> Table '{$table_name}', Index ({$cols}) - {$action}</p>\n";

        if ($action != 'create') {
            $q = "ALTER TABLE {$table_name} DROP INDEX {$name}";
            $this->storeQuery('drop_index', $q);
        }

        if ($type != 'INDEX') $type .= ' INDEX';

        $q = "ALTER TABLE {$table_name} ADD {$type} ({$cols})";
        $this->storeQuery('add_index', $q);


        return true;
    }


    /**
    * Checks that the specified foreign key exists in the table
    * If the foreign key is incorrect, it will be altered
    * If the foreign key does not exist, it will be created
    *
    * @param string $table_name The name of the table to check
    * @param array $foreign key The foreign key definition to check
    * @tag maybe-error-not-mysql
    **/
    private function checkForeignKeyMatches($table_name, $foreign_key)
    {
        $dbname = Kohana::config('database.default.connection.database');

        $delete = self::$foreign_key_actions[$foreign_key['delete']];
        $update = self::$foreign_key_actions[$foreign_key['update']];

        $pf = Pdb::prefix();
        $current_fks = self::foreignKeyList($table_name);
        foreach ($current_fks as $id => $fk) {
            $ignore = false;
            if ($foreign_key['from_column'] != $fk['COLUMN_NAME']) $ignore = true;
            if ($pf . $foreign_key['to_table'] != $fk['REFERENCED_TABLE_NAME']) $ignore = true;
            if ($foreign_key['to_column'] != $fk['REFERENCED_COLUMN_NAME']) $ignore = true;
            if ($fk['UPDATE_RULE'] != $update or $fk['DELETE_RULE'] != $delete) $ignore = true;
            if ($ignore) unset($current_fks[$id]);
        }

        if (count($current_fks) > 1) {
            echo "<p>Warning - multiple foreign keys found for column:";
            foreach ($current_fks as $row) {
                echo "<br>Use 'ALTER TABLE ~{$table_name} DROP FOREIGN KEY {$row['CONSTRAINT_NAME']}' to drop this fk\n";
            }
            echo "<br>";
        }

        if (count($current_fks) != 0) {
            return true;
        }

        $this->heading = "<p class=\"heading\"><b>FRN KEY</b> Table '{$table_name}', Foreign key {$foreign_key['from_column']} -> {$foreign_key['to_table']}.{$foreign_key['to_column']}</p>\n";

        // Look for records which fail to join to the foreign table
        $message = '';
        try {
            $q = "SELECT COUNT(*)
                FROM ~{$table_name} AS main
                LEFT JOIN ~{$foreign_key['to_table']} AS extant ON main.{$foreign_key['from_column']} = extant.{$foreign_key['to_column']}
                WHERE extant.id IS NULL;";
            $num_invalid_records = Pdb::query($q, [], 'val');
            if ($num_invalid_records > 0) {
                echo "<p>Warning - {$num_invalid_records} invalid records found ";
                echo "in <i>{$table_name}</i> table (foreign key on <i>{$foreign_key['from_column']}</i> column)";

                $find_q = str_replace('COUNT(*)', "main.id, main.{$foreign_key['from_column']}", $q);

                $delete_q = "DELETE FROM ~{$table_name}
                    WHERE {$foreign_key['from_column']} NOT IN (SELECT id FROM ~{$foreign_key['to_table']});";

                $null_q = "UPDATE ~{$table_name}
                    SET {$foreign_key['from_column']} = NULL
                    WHERE {$foreign_key['from_column']} NOT IN (SELECT id FROM ~{$foreign_key['to_table']});";

                echo '<div class="columns">';

                echo '<div class="column column-4">';
                echo '<p>Find records:</p>';
                echo '<pre>';
                echo Pdb::prettyQueryIndentation($find_q);
                echo '</pre>';
                echo '</div>';

                echo '<div class="column column-4">';
                echo '<p>Delete records:</p>';
                echo '<pre>';
                echo Pdb::prettyQueryIndentation($delete_q);
                echo '</pre>';
                echo '</div>';

                echo '<div class="column column-4 column-last">';
                echo '<p>NULL offending values:</p>';
                echo '<pre>';
                echo Pdb::prettyQueryIndentation($null_q);
                echo '</pre>';
                echo '</div>';

                echo '</div>';
                echo '<p>&nbsp;</p>';
            }
        } catch (QueryException $ex) {
            $message = "<p>Warning - query error looking for invalid records; does the table '{$foreign_key['to_table']}' exist?</p>\n";
        }

        $q = "ALTER TABLE ~{$table_name} ADD FOREIGN KEY ({$foreign_key['from_column']})
            REFERENCES ~{$foreign_key['to_table']} ({$foreign_key['to_column']})
            ON DELETE {$delete}
            ON UPDATE {$update}";
        $this->storeQuery('add_fk', $q, $message);

        return true;
    }


    /**
    * Find and remove unused columns
    **/
    private function checkRemovedColumns($table_name, $defined_columns)
    {
        $columns = $this->fieldList($table_name);
        $table_name = Pdb::prefix() . $table_name;

        foreach ($columns as $col) {
            $found = false;
            foreach ($defined_columns as $def_col) {
                if ($def_col['name'] == $col['Field']) {
                    $found = true;
                    break;
                }
            }

            if (! $found) {
                // Check column isn't an old name for a column which has been or will be replaced upon sync
                foreach ($defined_columns as $other_col) {
                    if ($other_col['name'] == $col['Field']) continue;

                    if (!$other_col['previous-names']) continue;

                    $prevs = preg_split('/,\s*/', $other_col['previous-names']);
                    if (in_array($col['Field'], $prevs)) {
                        return;
                    }
                }

                $this->heading = "<p class=\"heading\"><b>REMOVED</b> Table '{$table_name}', Column '{$col['Field']}'</p>\n";

                $q = "ALTER TABLE {$table_name} DROP COLUMN {$col['Field']}";
                $this->storeQuery('drop_column', $q);
            }
        }
    }


    /**
    * Find and remove unused indexes
    **/
    private function checkRemovedIndexes($table_name, $defined_indexes)
    {
        $db_indexes = $this->indexList($table_name);
        $table_name = Pdb::prefix() . $table_name;

        foreach ($db_indexes as $db_ind) {
            if ($db_ind['Name'] == 'PRIMARY') continue;

            $found = false;
            foreach ($defined_indexes as $def_index) {
                $def_type = strtoupper($def_index['type']);
                unset ($def_index['type']);
                $def_columns = $def_index;

                if ($def_type == $db_ind['Type'] and $def_columns == $db_ind['Columns']) {
                    $found = true;
                    break;
                }
            }

            if (! $found) {
                $this->heading = "<p class=\"heading\"><b>REMOVED</b> Table '{$table_name}', Index '{$db_ind['Name']}'</p>\n";

                $q = "ALTER TABLE {$table_name} DROP INDEX {$db_ind['Name']}";
                $this->storeQuery('drop_index', $q);
            }
        }
    }


    /**
    * Find and remove unused foreign keys
    **/
    private function checkRemovedForeignKeys($table_name, $defined_foreign_keys)
    {
        $dbname = Kohana::config('database.default.connection.database');

        $current_fks = self::foreignKeyList($table_name);

        $pf = Pdb::prefix();
        $table_name = $pf . $table_name;

        foreach ($current_fks as $fk) {
            $found = false;
            foreach ($defined_foreign_keys as $def_fk) {
                $delete = self::$foreign_key_actions[$def_fk['delete']];
                $update = self::$foreign_key_actions[$def_fk['update']];

                if ($def_fk['from_column'] == $fk['COLUMN_NAME']
                    and
                    $pf . $def_fk['to_table'] == $fk['REFERENCED_TABLE_NAME']
                    and
                    $def_fk['to_column'] == $fk['REFERENCED_COLUMN_NAME']
                    and
                    $update == $fk['UPDATE_RULE']
                    and
                    $delete == $fk['DELETE_RULE']
                ) {
                    $found = true;
                    break;
                }
            }

            if (! $found) {
                $this->heading = "<p class=\"heading\"><b>REMOVED</b> Table '{$table_name}', Foreign key '{$fk['CONSTRAINT_NAME']}'</p>\n";

                $q = "ALTER TABLE {$table_name} DROP FOREIGN KEY {$fk['CONSTRAINT_NAME']}";
                $this->storeQuery('drop_fk', $q);
            }
        }
    }


    /**
    * Create or update  a view
    **/
    private function createView($view_name, $view_def)
    {
        $view_name = trim($view_name);
        $view_def = trim($view_def);

        $q = "DROP VIEW ~{$view_name}";
        $this->reportAndExecute($q);

        $q = "CREATE VIEW ~{$view_name}\nAS\n\t{$view_def}";
        $this->reportAndExecute($q);
    }


    /**
     * Stores a query in a list of queries to run
     * @param string $type One of the types listed in {@see DatabaseSync::$query_types}
     * @param string|array $query The query or queries.
     *        If an array, each query will be tried until one succeeds or all have failed.
     * @param string $message A message to display after the query
     * @return bool True
     * @throws Exception if unknown query type
     */
    private function storeQuery($type, $query, $message = '')
    {
        if (!in_array($type, self::$query_types)) {
            throw new Exception('Unknown query type: ' . $type);
        }
        $this->queries[$type][] = [$query, $this->heading, $message];
        return true;
    }


    /**
    * Outputs and executes the specified query
    *
    * @param string|array $q The SQL statement(s) to execute.
    *        If an array, each query will be tried until one succeeds or all have failed.
    **/
    private function reportAndExecute($q)
    {
        static $log_handler = null;

        if (!$log_handler) {
            $log_handler = function($q, $params, $result) {
                $q = trim($q);
                $q = preg_replace("/,\n$/", "\n)", $q);
                $q = preg_replace('/\n\s*/', "\n    ", $q);
                echo '<pre class="query">', Enc::html($q), "</pre>\n";
            };
        }

        if ($this->act) {
            Pdb::setLogHandler($log_handler);

            $qs = (array) $q;
            $keys = array_keys($qs);
            $final_key = end($keys);
            foreach ($qs as $key => $q) {
                try {
                    Pdb::query($q, [], 'pdo');
                    break;
                } catch (QueryException $ex) {
                    if ($key != $final_key) {
                        // Only the final query matters
                        echo '<p class="error">Failed; reverting to fallback query</p>';
                    } else {
                        echo '<ul class="messages all-type-error"><li class="error">', Enc::html($ex->getMessage()), '</li></ul>';
                    }
                }
            }

            Pdb::clearLogHandler();
        } else {
            if (is_array($q)) $q = end($q);
            $log_handler($q, [], null);
        }

        return true;
    }
}


